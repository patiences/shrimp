use std::str::FromStr;

grammar; 

Program: Box<Program> = {
    <(Statement)*> "print" <Expression> = Box::new(Program(<>))
};

Statement: Box<Statement> = {
    Assign,
};

Assign: Box<Statement> = {
    <Identifier> "=" <Expression> => Box::new(Statement::Assign(<>))
};

Identifier: str = {
    IDENTIFIER
};

ExpressionList: Vec<Box<Expression>> = {
    <e:Expression> <elist:("," <Expression>)>* => match elist {
        None => {
            vec![e]
        },
        Some => {
            let v = vec![e]
            for e in elist {
                v.push(e);
            }
            v
        }
    }
};

Expression: Box<Expression> = {
    <CompExpression> "?" <Expression> ":" <Expression> =>
    Box::new(Expression::Conditional(<>)),
    CompExpression, 
};

CompExpression: Box<Expression> = {
    <AddExpression> "<" <AddExpression> => Box::new(Expression::LessThan(<>)),
    AddExpression,
};

AddExpression: Box<Expression> = { 
    <MultExpression> "+" <MultExpression> => Box::new(Expression::Plus(<>)),
    <MultExpression> "-" <MultExpression> => Box::new(Expression::Minus(<>)),
    MultExpression, 
};

MultExpression: Box<Expression> = {
    <NotExpression> "*" <NotExpression> => Box::new(Expression::Times(<>)),
    NotExpression,
};

NotExpression: Box<Expression> = {
    "!" NotExpression => Box::new(Expression::Not(<>)),
    PrimaryExpression,
};

// Expressions with the highest precedence 
PrimaryExpression: Box<Expression> = {
    IntegerLiteral => Box::new(Expression::IntegerLiteral(<>)), 
    Identifier => Box::new(Expression::IdentifierExp(<>), 
    "(" <Expression> ")"  
}

// Tokens 
INTEGER_LITERAL: i32 = {
    (DIGIT)+ => i32::from_str(<>).unwrap() // 1 or more digits 
}; 


// FIXME turn these guys into strings 
IDENTIFIER: str = {
    LETTER,  //  Single letter
    (LETTER | "_" | DIGIT)* // Any combination of letters/_/digits
}; 

LETTER: char = { r"[A-Z, a-z]" => <>.unwrap() }; // can I do this? 

DIGIT: i32 = { r"[0-9]" => i32::from_str(<>).unwrap() };
